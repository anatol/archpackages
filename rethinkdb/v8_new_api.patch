diff --git a/mk/support.mk b/mk/support.mk
index dba12e8..854160e 100644
--- a/mk/support.mk
+++ b/mk/support.mk
@@ -149,7 +149,7 @@ $(NODE_MODULES_DIR)/handlebars: $(NPM_DEP) | $(NODE_MODULES_DIR)/.
 $(V8_SRC_DIR):
 	$P SVN-CO v8
 	( cd $(TC_SRC_DIR) && \
-	  svn checkout http://v8.googlecode.com/svn/tags/3.17.4.1 v8 ) $(SUPPORT_LOG_REDIRECT)
+	  svn checkout http://v8.googlecode.com/svn/tags/3.19.18.4 v8 ) $(SUPPORT_LOG_REDIRECT)
 
 	$P MAKE v8 dependencies
 	$(EXTERN_MAKE) -C $(V8_SRC_DIR) dependencies $(SUPPORT_LOG_REDIRECT)
diff --git a/src/rdb_protocol/js.cc b/src/rdb_protocol/js.cc
index 671623f..261644c 100644
--- a/src/rdb_protocol/js.cc
+++ b/src/rdb_protocol/js.cc
@@ -65,10 +65,10 @@ env_t::env_t(extproc::job_control_t *control)
 
 env_t::~env_t() {
     // Clean up handles.
-    for (std::map<id_t, v8::Persistent<v8::Value> >::iterator it = values_.begin();
+    for (std::map<id_t, boost::shared_ptr<v8::Persistent<v8::Value> > >::iterator it = values_.begin();
          it != values_.end();
          ++it)
-        it->second.Dispose();
+        it->second->Dispose();
 }
 
 void env_t::run() {
@@ -80,14 +80,25 @@ void env_t::run() {
 
 void env_t::shutdown() { should_quit_ = true; }
 
-id_t env_t::rememberValue(v8::Handle<v8::Value> value) {
+id_t env_t::rememberValue(const v8::Handle<v8::Value> &value) {
     id_t id = new_id();
-    values_.insert(std::make_pair(id, v8::Persistent<v8::Value>::New(value)));
+
+    // Save this value in a persistent handle so it isn't deallocated when
+    // its scope is destructed.
+    
+#ifdef V8_PRE_3_19
+    boost::shared_ptr<v8::Persistent<v8::Value> > persistent_handle(new v8::Persistent<v8::Value>(value));
+#else
+    boost::shared_ptr<v8::Persistent<v8::Value> > persistent_handle(new v8::Persistent<v8::Value>());
+    persistent_handle->Reset(v8::Isolate::GetCurrent(), value);
+#endif
+
+    values_.insert(std::make_pair(id, persistent_handle));
     return id;
 }
 
-v8::Handle<v8::Value> env_t::findValue(id_t id) {
-    std::map<id_t, v8::Persistent<v8::Value> >::iterator it = values_.find(id);
+const boost::shared_ptr<v8::Persistent<v8::Value> >env_t::findValue(id_t id) {
+    std::map<id_t, boost::shared_ptr<v8::Persistent<v8::Value> > >::iterator it = values_.find(id);
     guarantee(it != values_.end());
     return it->second;
 }
@@ -324,10 +335,19 @@ struct call_task_t : auto_task_t<call_task_t> {
         js_result_t result("");
         std::string *errmsg = boost::get<std::string>(&result);
 
+        const boost::shared_ptr<v8::Persistent<v8::Value> > found_value = env->findValue(func_id_);
+        guarantee(!found_value->IsEmpty());
+
         v8::HandleScope handle_scope;
-        v8::Handle<v8::Function> func
-            = v8::Handle<v8::Function>::Cast(env->findValue(func_id_));
-        guarantee(!func.IsEmpty());
+
+        // Construct local handle from persistent handle
+
+#ifdef V8_PRE_3_19
+        v8::Local<v8::Value> local_handle = v8::Local<v8::Value>::New(*found_value);
+#else
+        v8::Local<v8::Value> local_handle = v8::Local<v8::Value>::New(v8::Isolate::GetCurrent(), *found_value);
+#endif
+        v8::Local<v8::Function> func = v8::Local<v8::Function>::Cast(local_handle);
 
         v8::Handle<v8::Value> value = eval(func, errmsg);
         if (!value.IsEmpty()) {
diff --git a/src/rdb_protocol/jsimpl.hpp b/src/rdb_protocol/jsimpl.hpp
index d67bf3e..cff1082 100644
--- a/src/rdb_protocol/jsimpl.hpp
+++ b/src/rdb_protocol/jsimpl.hpp
@@ -32,7 +32,7 @@ class job_control_t;
 namespace js {
 
 // Returns an empty pointer on error.
-boost::shared_ptr<scoped_cJSON_t> toJSON(const v8::Handle<v8::Value> value,
+boost::shared_ptr<scoped_cJSON_t> toJSON(const v8::Handle<v8::Value> &value,
                                          std::string *errmsg);
 
 // Should never error.
@@ -54,9 +54,9 @@ class env_t {
   public:                       // Interface exposed to JS tasks.
     extproc::job_control_t *control() { return control_; }
 
-    id_t rememberValue(v8::Handle<v8::Value> value);
+    id_t rememberValue(const v8::Handle<v8::Value> &value);
 
-    v8::Handle<v8::Value> findValue(id_t id);
+    const boost::shared_ptr<v8::Persistent<v8::Value> >findValue(id_t id);
 
     void forget(id_t id);
 
@@ -71,17 +71,29 @@ class env_t {
     extproc::job_control_t *control_;
     bool should_quit_;
     id_t next_id_;
-    std::map<id_t, v8::Persistent<v8::Value> > values_;
+    std::map<id_t, boost::shared_ptr<v8::Persistent<v8::Value> > > values_;
 };
 
 
 // Puts us into a fresh v8 context.
 // By default each task gets its own context.
 struct context_t {
-    explicit context_t(UNUSED env_t *env) : cx(v8::Context::New()), scope(cx) {}
-    ~context_t() { cx.Dispose(); }
+#ifdef V8_PRE_3_19
+    explicit context_t(UNUSED env_t *env) :
+        cx(v8::Context::New()),
+        scope(cx) {}
+
     v8::Persistent<v8::Context> cx;
     v8::Context::Scope scope;
+#else
+    explicit context_t(UNUSED env_t *env) :
+        cx(v8::Context::New(v8::Isolate::GetCurrent())),
+        scope(cx) {}
+
+    v8::HandleScope local_scope;
+    v8::Local<v8::Context> cx;
+    v8::Context::Scope scope;
+#endif
 };
 
 // Tasks: jobs we run on the JS worker, within an env_t
diff --git a/src/rdb_protocol/tofromjson.cc b/src/rdb_protocol/tofromjson.cc
index 57ea311..ed07706 100644
--- a/src/rdb_protocol/tofromjson.cc
+++ b/src/rdb_protocol/tofromjson.cc
@@ -18,7 +18,7 @@ namespace js {
 //
 // TODO(rntz): Is there a better way of detecting cyclic data structures than
 // using a recursion limit?
-static cJSON *mkJSON(const v8::Handle<v8::Value> value, int recursion_limit, std::string *errmsg) {
+static cJSON *mkJSON(const v8::Handle<v8::Value> &value, int recursion_limit, std::string *errmsg) {
     if (0 == recursion_limit) {
         *errmsg = "toJSON recursion limit exceeded (cyclic datastructure?)";
         return NULL;
@@ -162,7 +162,7 @@ static cJSON *mkJSON(const v8::Handle<v8::Value> value, int recursion_limit, std
     }
 }
 
-boost::shared_ptr<scoped_cJSON_t> toJSON(const v8::Handle<v8::Value> value, std::string *errmsg) {
+boost::shared_ptr<scoped_cJSON_t> toJSON(const v8::Handle<v8::Value> &value, std::string *errmsg) {
     guarantee(!value.IsEmpty());
     guarantee(errmsg);
 
